struct VS_OUTPUT
{
    float4 position : POSITION0;

#ifdef PNORMAL
    float3 normal : TEXCOORD0;
#endif

#ifdef PCOLOR
    float4 color : COLOR0;
#endif

#ifdef PTEX0
    float4 tex0 : TEXCOORD1;
#endif

#ifdef PPOS
    float3 pos0 : TEXCOORD2;
#endif

#ifdef LIGHTVS
    float4 specular0 : TEXCOORD3;

#ifdef TEXSHADE
    float2 tex2 : TEXCOORD4;
#endif
#endif //LIGHTVS

};
static const float c_fzero = 0.0;
static const float c_fone = 1.0;
static const float PI = 3.14159265358979323846;
static const float PI2 = 6.28318530717958647692;
static const float INV_PI = 0.31830988618379067153;
static const float INV_PI2 = 0.15915494309189533576;

////////////////////////////////////
#ifdef LIGHTVS
uniform float3 ambient;
uniform float4 dlColor;

uniform float4 diffuse;
uniform float3 emissive;

#else //LIGHTVS

uniform float3 dlDir;
uniform float4 dlColor;
uniform float3 camPos;

uniform float4 diffuse;
uniform float3 ambient;
uniform float3 emissive;

#endif //LIGHTVS

// textures
#ifdef PTEX0
sampler texAlbedo;
sampler texAlbedo2;
#endif

#ifdef FRESNEL

static const float c_ffive = 5.0;
static const float c_fresnel0 = 0.0397436;
static const float c_fresnel1 = 0.0856832;

uniform float4 specular;
uniform float fresnel;

// calculate fresnel term for diffuse and specular
void calc_fresnel(out float fd, out float fs, float F, float eh, float nl)
{
  float F2 = c_fone - F;
  fs = F + F2*pow((c_fone - eh), c_ffive);
  fd = F + F2*pow((c_fone - nl), c_ffive);
}

#elif defined(TEXSHADE) || defined(PNORMAL)
static const float c_fhalf = 0.5;
static const float c_fratio = 0.75;

static const float c_ffive = 5.0;
static const float c_fresnel0 = 0.0397436;
static const float c_fresnel1 = 0.0856832;
static const float c_fresnel = 1.5;

uniform float4 specular;

// calculate fresnel term for diffuse and specular
void calc_fresnel(out float fd, out float fs, float eh, float nl)
{
  float F2 = c_fone - c_fresnel;
  fs = c_fresnel + F2*pow((c_fone - eh), c_ffive);
  fd = c_fresnel + F2*pow((c_fone - nl), c_ffive);
}

#endif


float4 main(VS_OUTPUT input) : COLOR
{
    // 色計算
    //-------------
    float4 color;
#ifdef TEXALBEDO
    //ディフューズテクスチャ参照
    color = tex2D(texAlbedo, input.tex0.xy);
#else
    color = diffuse;
#endif

#ifdef PCOLOR
    color *= input.color0;
#endif

#ifdef LIGHTVS

#ifdef TEXSHADE
    float3 c = tex2D(texAlbedo2, input.tex2).xyz;
    float3 power = min(dlColor.xyz * diffuse.xyz + ambient, c_fone);

    color.xyz = (color.xyz * c) * power + dlColor.xyz*input.specular0.xyz;

#else
    float3 power = min(dlColor.xyz * diffuse.xyz + ambient, c_fone);
    color.xyz = (color.xyz * input.specular0.w) * power + dlColor.xyz*input.specular0.xyz;
#endif //TEXSHADE

#elif defined(TEXSHADE)
    float3 N = normalize(input.normal);
    float3 L = dlDir;
    float3 E = normalize(camPos - input.pos0);
    float3 H = normalize(L+E); //half vector

    float cosNL = max(c_fzero, dot(N,L));
    float cosNH = max(c_fzero, dot(N,H));
    //float cosNE = max(c_fzero, dot(N,E));

    float2 sample;
    //sample.x = cosNE; //こちら側はカット
    sample.x = cosNL;
    sample.y = cosNL;

    float3 c = tex2D(texAlbedo2, sample).xyz;

    float shininess = specular.w;

    float rs = pow(cosNH, shininess);

    color.xyz = (color.xyz * c + specular.xyz * rs) * dlColor.xyz + ambient * color.xyz;

#elif defined(PNORMAL)
    float3 N = normalize(v_normal);
    float3 L = dlDir;
    float3 E = normalize(camPos - v_pos0);
    float3 H = normalize(L+E); //half vector

    float cosNH = max(c_fzero, dot(N,H));
    //float cosNE = max(c_fzero, dot(N,E));

    float shininess = specular.w;
    float rs = pow(cosNH, shininess);

    color.xyz = (color.xyz * cosNH + specular.xyz * rs) * dlColor.xyz + ambient * color.xyz;

#else
    color.xyz *= dlColor.xyz;
#endif

#ifdef EMISSIVE
    color.xyz += emissive;
#endif

    return color;
}
