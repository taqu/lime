#define MAX_CASCADES 4
#define NUM_CASCADES 2
static const float PI = 3.14159265;
static const float INV_PI = 0.31830988618379067153;

#define SHADOWMAP_TYPE_NOFILTER (0)
#define SHADOWMAP_TYPE_PCF (1)
#define SHADOWMAP_TYPE_MSM (2)
#define SHADOWMAP_TYPE_OPTIMIZEDMSM (3)

#define SHADOWMAP_TYPE SHADOWMAP_TYPE_OPTIMIZEDMSM

#define PCF_FILTER_SIZE (5)

cbuffer PerFrameConstant : register(b0)
{
};

cbuffer PerLightConstant : register(b1)
{
    float4 dlDir;
    float4 dlColor;

    float shadowMapSize;
    float specularMapMipLevels;
    float invShadowMapSize;
    int shadowMapUVToTexel;

    float shadowMapMomentBias;
    float shadowMapDepthBias;
    float lightBleedingBias;
    int clusterGridScale;
};

cbuffer PerCameraConstant : register(b2)
{
    float4x4 mview;
    float4x4 minvview;
    float4x4 mproj;
    float4x4 minvproj;
    float4x4 mvp0; //previous vew projection
    float4x4 mvp1; //current view projection
    float4 cameraPos;
    int2 screenSize; //(screenWidth, screenHeight)
    float2 screenInvSize; //(screenInvWidth, screenInvHeight)
}

cbuffer LightClusterConstant : register(b3)
{
    int4 lightClusterSize;
    float4 lightClusterScale;
    float4 lightClusterBias;
}

cbuffer MaterialConstant : register(b4)
{
    float4 diffuse;
    float4 specular;
    float4 ambient;
    float4 shadow;
}

Texture2D texAlbedo : register(t0);
SamplerState samAlbedo : register(s0);

Texture2D texNormal : register(t1);
SamplerState samNormal : register(s1);

TextureCube texSpecular : register(t2);
SamplerState samSpecular : register(s2);

Texture2DArray texShadow : register(t3);
#if SHADOWMAP_TYPE==SHADOWMAP_TYPE_NOFILTER || SHADOWMAP_TYPE==SHADOWMAP_TYPE_PCF
SamplerComparisonState samShadow : register(s3);
#else
SamplerState samShadow : register(s3);
#endif

TextureCube texIrradiance : register(t4);
SamplerState samIrradiance : register(s4);

struct PointLight
{
    float3 position;
    float attenuation0;
    float3 color;
    float attenuation1;
};

StructuredBuffer<PointLight> lightBuffer : register(t5);
Texture2D<uint> lightIndices : register(t6);
Texture3D<uint2> lightClusters : register(t7);

struct DeferredOutput
{
    float4 albedo : SV_TARGET0;
    float4 specular : SV_TARGET1;
    float4 normal : SV_TARGET2;
    float2 velocity : SV_TARGET3;
};

float RGBToLum(float3 v)
{
    return dot(v, float3(0.299, 0.587, 0.114));
}

void lightSpaceTexcoord(inout float4 uv)
{
    uv.xy = uv.xy*float2(0.5,-0.5)+float2(0.5,0.5);
}


float sampleShadowMap(Texture2DArray texShadow, SamplerComparisonState samShadow, float2 baseUV, float du, float dv, float depth, int cascade)
{
    float2 uv = baseUV + float2(du,dv) * invShadowMapSize;
    return texShadow.SampleCmpLevelZero(samShadow, float3(uv, cascade), depth).r;
}

float sampleShadowMapOne(Texture2DArray texShadow, SamplerComparisonState samShadow, float4 tex, int cascade)
{
    return texShadow.SampleCmpLevelZero(samShadow, float3(tex.xy, cascade), tex.z).r;
}

float sampleShadowPCF(Texture2DArray texShadow, SamplerComparisonState samShadow, float4 tex, int cascade)
{
    float2 pos = tex.xy*shadowMapUVToTexel;
    float2 baseUV = floor(pos+float2(0.5,0.5));
    float2 dpos = pos + float2(0.5,0.5) - baseUV;
    baseUV = (baseUV - float2(0.5,0.5))*invShadowMapSize;

#if PCF_FILTER_SIZE == 3
    float2 dpos2 = dpos*2;
    float2 weight0 = float2(3,3)-dpos2;
    float2 weight1 = float2(1,1)+dpos2;
    float2 duv0 = (float2(2,2)-dpos)/weight0 - float2(1,1);
    float2 duv1 = dpos/weight1 + 1;

    float sum = 0;
    sum += weight0.x * weight0.y * sampleShadowMap(texShadow, samShadow, baseUV, duv0.x, duv0.y, tex.z, cascade);
    sum += weight1.x * weight0.y * sampleShadowMap(texShadow, samShadow, baseUV, duv1.x, duv0.y, tex.z, cascade);
    sum += weight0.x * weight1.y * sampleShadowMap(texShadow, samShadow, baseUV, duv0.x, duv1.y, tex.z, cascade);
    sum += weight1.x * weight1.y * sampleShadowMap(texShadow, samShadow, baseUV, duv1.x, duv1.y, tex.z, cascade);
    return sum * (1.0/16);

#elif PCF_FILTER_SIZE == 5
    float2 weight0 = float2(4,4) - 3*dpos;
    float2 weight1 = 7;
    float2 weight2 = float2(1,1) + 3*dpos;

    float2 duv0 = (float2(3,3) - 2*dpos)/weight0 - float2(2,2);
    float2 duv1 = (float2(3,3) + dpos)/weight1;
    float2 duv2 = dpos/weight2 + float2(2,2);

    float sum = 0;
    sum += weight0.x * weight0.y * sampleShadowMap(texShadow, samShadow, baseUV, duv0.x, duv0.y, tex.z, cascade);
    sum += weight1.x * weight0.y * sampleShadowMap(texShadow, samShadow, baseUV, duv1.x, duv0.y, tex.z, cascade);
    sum += weight2.x * weight0.y * sampleShadowMap(texShadow, samShadow, baseUV, duv2.x, duv0.y, tex.z, cascade);

    sum += weight0.x * weight1.y * sampleShadowMap(texShadow, samShadow, baseUV, duv0.x, duv1.y, tex.z, cascade);
    sum += weight1.x * weight1.y * sampleShadowMap(texShadow, samShadow, baseUV, duv1.x, duv1.y, tex.z, cascade);
    sum += weight2.x * weight1.y * sampleShadowMap(texShadow, samShadow, baseUV, duv2.x, duv1.y, tex.z, cascade);

    sum += weight0.x * weight2.y * sampleShadowMap(texShadow, samShadow, baseUV, duv0.x, duv2.y, tex.z, cascade);
    sum += weight1.x * weight2.y * sampleShadowMap(texShadow, samShadow, baseUV, duv1.x, duv2.y, tex.z, cascade);
    sum += weight2.x * weight2.y * sampleShadowMap(texShadow, samShadow, baseUV, duv2.x, duv2.y, tex.z, cascade);
    return sum * (1.0/144);

 #else
    float2 weight0 = 5*dpos - float2(6,6);
    float2 weight1 = 11*dpos - float2(28,28);
    float2 weight2 = -11*dpos - float2(17,17);
    float2 weight3 = -5*dpos - float2(1,1);

    float2 duv0 = (4*dpos-float2(5,5))/weight0 - float2(3,3);
    float2 duv1 = (4*dpos-float2(16,16))/weight1 - float2(1,1);
    float2 duv2 = (-7*dpos-float2(5,5))/weight2 + float2(1,1);
    float2 duv3 = -dpos/weight3 + float2(3,3);

    float sum = 0;
    sum += weight0.x * weight0.y * sampleShadowMap(texShadow, samShadow, baseUV, duv0.x, duv0.y, tex.z, cascade);
    sum += weight1.x * weight0.y * sampleShadowMap(texShadow, samShadow, baseUV, duv1.x, duv0.y, tex.z, cascade);
    sum += weight2.x * weight0.y * sampleShadowMap(texShadow, samShadow, baseUV, duv2.x, duv0.y, tex.z, cascade);
    sum += weight3.x * weight0.y * sampleShadowMap(texShadow, samShadow, baseUV, duv3.x, duv0.y, tex.z, cascade);

    sum += weight0.x * weight1.y * sampleShadowMap(texShadow, samShadow, baseUV, duv0.x, duv1.y, tex.z, cascade);
    sum += weight1.x * weight1.y * sampleShadowMap(texShadow, samShadow, baseUV, duv1.x, duv1.y, tex.z, cascade);
    sum += weight2.x * weight1.y * sampleShadowMap(texShadow, samShadow, baseUV, duv2.x, duv1.y, tex.z, cascade);
    sum += weight3.x * weight1.y * sampleShadowMap(texShadow, samShadow, baseUV, duv3.x, duv1.y, tex.z, cascade);

    sum += weight0.x * weight2.y * sampleShadowMap(texShadow, samShadow, baseUV, duv0.x, duv2.y, tex.z, cascade);
    sum += weight1.x * weight2.y * sampleShadowMap(texShadow, samShadow, baseUV, duv1.x, duv2.y, tex.z, cascade);
    sum += weight2.x * weight2.y * sampleShadowMap(texShadow, samShadow, baseUV, duv2.x, duv2.y, tex.z, cascade);
    sum += weight3.x * weight2.y * sampleShadowMap(texShadow, samShadow, baseUV, duv3.x, duv2.y, tex.z, cascade);

    sum += weight0.x * weight3.y * sampleShadowMap(texShadow, samShadow, baseUV, duv0.x, duv3.y, tex.z, cascade);
    sum += weight1.x * weight3.y * sampleShadowMap(texShadow, samShadow, baseUV, duv1.x, duv3.y, tex.z, cascade);
    sum += weight2.x * weight3.y * sampleShadowMap(texShadow, samShadow, baseUV, duv2.x, duv3.y, tex.z, cascade);
    sum += weight3.x * weight3.y * sampleShadowMap(texShadow, samShadow, baseUV, duv3.x, duv3.y, tex.z, cascade);

    return sum * (1.0/2704);
 #endif
}

float linstep(float low, float high, float value)
{
    return saturate((value-low)/(high-low));
}

float reduceLightBleeding(float maxVal, float amount)
{
    return linstep(amount, 1.0, maxVal);
}

float4 decodeOptimizedMoments(in float4 optimizedMoments)
{
    optimizedMoments[0] -= 0.035955884801f;
    return mul(optimizedMoments, float4x4(0.2227744146f, 0.1549679261f, 0.1451988946f, 0.163127443f,
                                          0.0771972861f, 0.1394629426f, 0.2120202157f, 0.2591432266f,
                                          0.7926986636f, 0.7963415838f, 0.7258694464f, 0.6539092497f,
                                          0.0319417555f,-0.1722823173f,-0.2758014811f,-0.3376131734f));
}

float computeMSMHausdorff(float4 moments, float depth, float momentBias, float depthBias)
{
    // Bias input data to avoid artifacts
    float4 b = lerp(moments, float4(0.5,0.5,0.5,0.5), momentBias);
    float3 z;
    z[0] = depth-depthBias;

    // Compute a Cholesky factorization of the Hankel matrix B storing only non trivial entries or related products
	float L32D22=mad(-b[0],b[1],b[2]);
	float D22=mad(-b[0],b[0], b[1]);
	float squaredDepthVariance=mad(-b[1],b[1], b[3]);
	float D33D22=dot(float2(squaredDepthVariance,-L32D22),float2(D22,L32D22));
	float InvD22=1.0f/D22;
	float L32=L32D22*InvD22;

	// Obtain a scaled inverse image of bz=(1,z[0],z[0]*z[0])^T
	float3 c=float3(1.0f,z[0],z[0]*z[0]);
	// Forward substitution to solve L*c1=bz
	c[1]-=b.x;
	c[2]-=b.y+L32*c[1];
	// Scaling to solve D*c2=c1
	c[1]*=InvD22;
	c[2]*=D22/D33D22;
	// Backward substitution to solve L^T*c3=c2
	c[1]-=L32*c[2];
	c[0]-=dot(c.yz,b.xy);
	// Solve the quadratic equation c[0]+c[1]*z+c[2]*z^2 to obtain solutions z[1] 
	// and z[2]
	float p=c[1]/c[2];
	float q=c[0]/c[2];
	float D=(p*p*0.25)-q;
	float r=sqrt(D);
	z[1]=-p*0.5-r;
	z[2]=-p*0.5+r;

    float shadowIntensity;

	// Use a solution made of four deltas if the solution with three deltas is invalid
	if(z[1]<0.0f || z[2]>1.0f){
		float zFree=((b[2]-b[1])*z[0]+b[2]-b[3])/((b[1]-b[0])*z[0]+b[1]-b[2]);
		float w1Factor=(z[0]>zFree)? 1 : 0;
		shadowIntensity=(b[1]-b[0]+(b[2]-b[0]-(zFree+1.0f)*(b[1]-b[0]))*(zFree-w1Factor-z[0])
		                                        /(z[0]*(z[0]-zFree)))/(zFree-w1Factor)+1.0f-b[0];
	}
	// Use the solution with three deltas
	else{
		float4 switchVal = (z[2]<z[0])?float4(z[1],z[0],1.0,1.0):
            ((z[1]<z[0])?float4(z[0],z[1],0.0,1.0):
			float4(0,0,0,0));
		float quotient=(switchVal[0]*z[2]-b[0]*(switchVal[0]+z[2])+b[1])/((z[2]-switchVal[1])*(z[0]-z[1]));
		shadowIntensity=switchVal[2]+switchVal[3]*quotient;
	}

	return 1 - saturate(shadowIntensity);
}

float computeMSMHamburger(float4 moments, float depth, float momentBias, float depthBias)
{
    // Bias input data to avoid artifacts
    float4 b = lerp(moments, float4(0.5,0.5,0.5,0.5), momentBias);
    float3 z;
    z[0] = depth-depthBias;

    // Compute a Cholesky factorization of the Hankel matrix B storing only non trivial entries or related products
    float L32D22 = mad(-b[0], b[1], b[2]);
    float D22 = mad(-b[0], b[0], b[1]);
    float squaredDepthVariance = mad(-b[1], b[1], b[3]);
    float D33D22 = dot(float2(squaredDepthVariance, -L32D22), float2(D22, L32D22));
    float InvD22 = 1.0f / D22;
    float L32 = L32D22 * InvD22;

    // Obtain a scaled inverse image of bz = (1,z[0],z[0]*z[0])^T
    float3 c = float3(1.0f, z[0], z[0] * z[0]);

    // Forward substitution to solve L*c1=bz
    c[1] -= b.x;
    c[2] -= b.y + L32 * c[1];

    // Scaling to solve D*c2=c1
    c[1] *= InvD22;
    c[2] *= D22 / D33D22;

    // Backward substitution to solve L^T*c3=c2
    c[1] -= L32 * c[2];
    c[0] -= dot(c.yz, b.xy);

    // Solve the quadratic equation c[0]+c[1]*z+c[2]*z^2 to obtain solutions
    // z[1] and z[2]
    float p = c[1] / c[2];
    float q = c[0] / c[2];
    float D = (p * p * 0.25f) - q;
    float r = sqrt(D);
    z[1] =- p * 0.5f - r;
    z[2] =- p * 0.5f + r;

    // Compute the shadow intensity by summing the appropriate weights
    float4 switchVal = (z[2] < z[0]) ? float4(z[1], z[0], 1.0f, 1.0f) :
                      ((z[1] < z[0]) ? float4(z[0], z[1], 0.0f, 1.0f) :
                      float4(0.0f,0.0f,0.0f,0.0f));
    float quotient = (switchVal[0] * z[2] - b[0] * (switchVal[0] + z[2]) + b[1])/((z[2] - switchVal[1]) * (z[0] - z[1]));
    float shadowIntensity = switchVal[2] + switchVal[3] * quotient;
    return 1 - saturate(shadowIntensity);
}

float sampleShadowMSM(Texture2DArray texShadow, SamplerState samShadow, float4 tex, int cascade)
{
    float sample = texShadow.SampleLevel(samShadow, float3(tex.xy, cascade), 0).r;
    float sample2 = sample*sample;
    float4 moments = float4(sample, sample2, sample2*sample, sample2*sample2);
    float shadowIntensity = computeMSMHausdorff(moments, tex.z, shadowMapMomentBias, shadowMapDepthBias);
    //float shadowIntensity = computeMSMHamburger(moments, tex.z, shadowMapMomentBias, shadowMapDepthBias);
    return reduceLightBleeding(shadowIntensity, lightBleedingBias);
}

float sampleShadowOptimizedMSM(Texture2DArray texShadow, SamplerState samShadow, float4 tex, int cascade)
{
    float4 moments = decodeOptimizedMoments(texShadow.SampleLevel(samShadow, float3(tex.xy, cascade), 0));
    float shadowIntensity = computeMSMHausdorff(moments, tex.z, shadowMapMomentBias, shadowMapDepthBias);
    //float shadowIntensity = computeMSMHamburger(moments, tex.z, shadowMapMomentBias, shadowMapDepthBias);
    return reduceLightBleeding(shadowIntensity, lightBleedingBias);
}

float gatherShadowSample(Texture2DArray texShadow, float4 tex, int cascade)
{
    lightSpaceTexcoord(tex);
#if SHADOWMAP_TYPE==SHADOWMAP_TYPE_NOFILTER
    float shadowInfluence = sampleShadowMapOne(texShadow, samShadow, tex, cascade);

#elif SHADOWMAP_TYPE==SHADOWMAP_TYPE_PCF
    float shadowInfluence = sampleShadowPCF(texShadow, samShadow, tex, cascade);

#elif SHADOWMAP_TYPE==SHADOWMAP_TYPE_MSM
    float shadowInfluence = sampleShadowMSM(texShadow, samShadow, tex, cascade);

#elif SHADOWMAP_TYPE==SHADOWMAP_TYPE_OPTIMIZEDMSM
    float shadowInfluence = sampleShadowOptimizedMSM(texShadow, samShadow, tex, cascade);
#endif

    return shadowInfluence;
}

float calcShadowInfluence(Texture2DArray texShadow, float4 texS[NUM_CASCADES])
{
#if NUM_CASCADES<=1
    float4 tex = texS[0];
    lightSpaceTexcoord(tex);
    return gatherShadowSample(texShadow, tex, 0);
#else
    for(int i=0; i<NUM_CASCADES; ++i){
        float4 tex = texS[i];
        if(min(tex.x, tex.y)>=-1
            && max(tex.x, tex.y)<=1)
        {
            return gatherShadowSample(texShadow, tex, i);
        }
    }
    return 1;
#endif
}

#ifdef NPBR
void calcFresnel(out float rd, out float rs, float F0, float cosLH)
{
    float F1 = 1 - F0;
    rs = F0 + F1*pow(1-cosLH, 5);
    rd = F1;
}
#else
void calcFresnel(out float3 rd, out float3 rs, float3 F0, float cosLH)
{
    float3 F1 = 1 - F0;
    rs = F0 + F1*pow(1-cosLH, 5);
    rd = F1;
}

float3 envFresnel(float3 F0, float cosNE, float alpha)
{
    float3 F1 = max(1-alpha, F0)- F0;
    return F0 + F1*pow(1-cosNE, 5);
}

#endif

//Generalized-Trowbridge-Reitz. alpha = roughness^2
float NDF(float cosNH, float alpha)
{
    float cosNH2 = cosNH*cosNH;
    float sinNH2 = 1-cosNH2;
    float alpha2 = alpha*alpha;
    float inv = 1/(cosNH2*alpha2 + sinNH2);
    return INV_PI*alpha2*pow(inv,1.5);
}

// Optimized Smith GGX. alpha = roughness^2
// Smith GGX = G(l,v,h)/4(n,l)(n,v)
float Visibility(float cosNL, float cosNE, float alpha)
{
    float k = 0.5*alpha;
    float k1 = 1-k;
    float GL = (cosNL*k1 + k);
    float GV = (cosNE*k1 + k);
    return 0.25/(GL*GV);
}

float2 encodeVelocity(float2 velocity)
{
    return velocity;
}

float2 decodeVelocity(float2 encoded)
{
    return encoded;
}

float3 reconstructNormalFromXY(float2 n)
{
    float d = dot(n, n);
    return (1.5<d)? (float3)0 : float3(n, -sqrt(1.0-d));
}

void fillArray4(out int array[4], int4 src)
{
    array[0] = src.x;
    array[1] = src.y;
    array[2] = src.z;
    array[3] = src.w;
}

half3 gatherLights(float3 worldPosition, float3 viewPosition, float3 normal)
{
    int4 clusterPosition = int4(viewPosition * lightClusterScale.xyz + lightClusterBias.xyz, 0);

    half3 lit = (half3)0;

    uint2 cluster = lightClusters.Load(clusterPosition);
    uint lightIndex = cluster.x;
    uint lightCount = cluster.y;
    uint2 lightIndexCoord;
    for(uint pl=0; pl<lightCount; ++pl){
        lightIndexCoord.x = lightIndex & 63;
        lightIndexCoord.y = lightIndex >> 6;
        uint index = lightIndices[lightIndexCoord];
        ++lightIndex;

        const PointLight light = lightBuffer[index];

		// Lighting vectors
		float3 vec = light.position - worldPosition;
		float3 dir = normalize(vec);

		float attenuation = saturate(1.0 - dot(vec, vec) * rcp(light.attenuation1 * light.attenuation1));
        attenuation *= attenuation;

		// Lighting
		float diffuse = saturate(dot(dir, normal));

		lit += half3(light.color * (attenuation * diffuse));
    }
    return lit;
}
