#include "Common.ps"
#include "Volume.inc"

cbuffer VolumeConstantPS : register(b1)
{
    VolumeConstant g_volumeConstants[2];
}

cbuffer SceneConstant3 : register(b2)
{
    float3 g_cameraFoward;
    float g_time;
}

#include "SignedDistance.inc"

Texture2D<float4> texGradient : register(t1);
SamplerState samLinearClamp : register(s1);

Texture2D<float4> texEffect : register(t2);

float4 mapDisplacementToColor(float displacement, float2 uvScaleBias)
{
    float texcoord = saturate(mad(displacement, uvScaleBias.x, uvScaleBias.y));
    float4 color = texGradient.SampleLevel(samLinearClamp, float2(texcoord,0), 0);
    return color;
}

#if 0
float2 cartesianToSpherical(float3 cartesian)
{
  float2 spherical;

  spherical.x = atan2(cartesian.y, cartesian.x) * INV_PI;
  spherical.y = cartesian.z;

  return spherical * 0.5f + 0.5f;
}

float2 normal2SphericalUV(float3 n)
{
    return float2(atan2(n.y, n.x), acos(n.z)) * INV_PI;
}
#endif

float square(float2 uv)
{
    uv = abs(uv);
    float t = uv.x + uv.y;
    return smoothstep(0.9, 1.0, t)*(1-smoothstep(1.0, 1.1, t));
}

#define ROOT3 (1.73205080757)
#define HEXAGON_THRESHOLD (ROOT3*2)
#define HEXAGON_LOWER (ROOT3*2-0.7)
#define HEXAGON_UPPER (ROOT3*2+0.7)

float hexagon(float2 uv)
{
    float x0 = 2*abs(uv.y);
    float t0 = uv.x*ROOT3;
    float x1 = abs(t0 - uv.y);
    float x2 = abs(t0 + uv.y);
    float t = x0 + x1 + x2;
    return smoothstep(HEXAGON_LOWER, HEXAGON_THRESHOLD, t)*(1-smoothstep(HEXAGON_THRESHOLD, HEXAGON_UPPER, t));
}

float4 funcSphere(float3 pos, float3 spherePos, float time, float3 direction, float3 coordu, float3 coordv, in const VolumeConstant volumeConstant)
{
    float3 diff = pos-spherePos;
    float radius = length(diff);
    float3 normal = normalize(diff);
    float cs = smoothstep(0.5, 1, dot(direction, normal));

    float2 uv = 2*frac(mad(time, volumeConstant.noiseAnimation_.xy, float2(dot(normal, coordu), dot(normal,coordv))) * 3) - 1;
    float disc = hexagon(uv);
    float lower = volumeConstant.radius_*0.85;
    float upper = volumeConstant.radius_*0.9;
    float grad = step(lower, radius) * (1-step(upper, radius));
    float4 color;
    color.rgb = lerp(float3(0, 0, 1), float3(0.3,0.3,1), disc);

    grad *= cs;
    disc *= grad;
    color.a = lerp(grad, disc, 0.5);
    return color;
}

float4 funcExplosion(float3 pos, float3 spherePos, float time, float radius, in const VolumeConstant volumeConstant)
{
    float outDisplacement;
    float signedDistance = signedDistancePrimitiveDisplaced(pos, spherePos, radius, volumeConstant.noiseOctaves_, time, volumeConstant, outDisplacement);

    float4 color = mapDisplacementToColor(outDisplacement, volumeConstant.uvScaleBias_);
    
    float edgeFade = smoothstep(0.5+volumeConstant.edgeSoftness_, 0.5-volumeConstant.edgeSoftness_, signedDistance);
    color.a *= edgeFade;
    return color;
}

float4 main(DSOutput input) : SV_TARGET0
{
    const VolumeConstant volumeConstant = g_volumeConstants[input.mode];

    float3 start = mad(input.rayDirection, input.rayHitNearFar.x, cameraPos.xyz);
    float3 end = mad(input.rayDirection, input.rayHitNearFar.y, cameraPos.xyz);

    float3 stepV = input.rayDirection * volumeConstant.stepSize_;
    int numSteps = min(volumeConstant.maxSteps_, (int)floor((input.rayHitNearFar.y - input.rayHitNearFar.x)/volumeConstant.stepSize_));

    float4 output = (float4)0;
    float3 pos = start;
    int steps = 0;

    float opacity = volumeConstant.opacity_;
    if(input.mode == 0){
        for(int i=0; i<numSteps && output.a<opacity; ++i){
            float4 c=funcSphere(pos, input.worldPos, input.time, input.vector0, input.coordu, input.coordv, volumeConstant);
            output = blend(c, output);
            pos += stepV;
        }
    }else{
        float innerRadius = volumeConstant.radius_ - volumeConstant.displacement_;
        for(int i=0; i<numSteps && output.a<opacity; ++i){
            float4 c=funcExplosion(pos, input.worldPos, input.time, innerRadius, volumeConstant);
            output = blend(c, output);
            pos += stepV;
        }
    }
    output.a *= opacity;
    return output;
}
